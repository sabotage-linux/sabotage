#!/bin/sh
if [ -z "$S" ] ; then
	echo 'S not set, did you source config?'
	exit 1
fi
[ -z "$butch_staging_dir" ] && butch_staging_dir=/opt
[ -z "$butch_do_filelists" ] && butch_do_filelists=true
[ "$R" = "/" ] && R=
[ -z "$BUTCHDB" ] && BUTCHDB=/var/lib/butch.db

usage() {
	cat <<- EOF
	butch unpack : install binary package.
	- unpacks a distributable binary archive of a pkg
	- installs it into $R$butch_staging_dir
	- links it into $R
	- creates butch.db entry in $BUTCHDB
	may require root access.

	synopsis:
	butch unpack filename
	EOF
	exit 1
}
print_pkg_and_ver() {
	printf "%s %s\n" "$pkg" "$ver"
}

[ ! -e "$1" ] && usage
pkg=$(basename "$1" | cut -d '_' -f 1)
pl=$(printf "%s" "$pkg" | wc -b)
archnver=$(basename "$1" | cut -b $(($pl + 2))- | cut -d "." -f 1)
case $archnver in
	x86_64_*) arch=x86_64; ver=$(printf "%s\n" "$archnver" | cut -b 8-);;
	*)
	arch=$(printf "%s\n" "$archnver" | cut -d "_" -f 1)
	ver=$(printf "%s\n" "$archnver" | cut -d "_" -f 2);;
esac
[ "$arch" = "$A" ] || {
	echo "error: arch $arch of "$1" doesnt match arch $A of config!"
	exit 1
}

BINDIR=$(dirname $(readlink -f "$0"))
fn=$(readlink -f "$1")

[ -e "$R$butch_staging_dir/$pkg" ] && {
	$BINDIR/butch-rm "$pkg" || exit 1
}
tar -C "$R$butch_staging_dir" -xf "$fn" || {
	echo "error: could not extract $fn"
	exit 1
}
$BINDIR/butch-relink "$pkg" || {
	echo "error: could not link new pkg into place for installation"
	exit 1
}
print_pkg_and_ver >> "$BUTCHDB"
$butch_do_filelists && $BINDIR/butch-genfilelist "$pkg"
echo "successfully installed $pkg"
